package com.titan.gather.netty.handler;import io.netty.buffer.ByteBuf;import io.netty.buffer.Unpooled;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelFutureListener;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.SimpleChannelInboundHandler;import io.netty.handler.codec.http.*;import io.netty.handler.codec.http.websocketx.WebSocketFrame;import io.netty.util.CharsetUtil;import java.util.List;import java.util.Map;/** * @author: yupu * @Date: Created in 上午11:46 2018/9/25 * @Des: * @Modifyed By: */public class WebSocketServerHandler extends SimpleChannelInboundHandler<Object> {    @Override    protected void messageReceived(ChannelHandlerContext channelHandlerContext, Object o) throws Exception {        // 传统的Http接入        if (o instanceof FullHttpRequest){            handleHttpRequest(channelHandlerContext,(FullHttpRequest)o);        }        // websocket接入        if (o instanceof WebSocketFrame){            handleWebSocketFrame(channelHandlerContext,(WebSocketFrame)o);        }    }    @Override    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {        ctx.flush();    }    public void handleHttpRequest(ChannelHandlerContext channelHandlerContext,FullHttpRequest fullHttpRequest){        if (!fullHttpRequest.decoderResult().isSuccess() || (!"websocket".equals(fullHttpRequest.headers().get("Upgrade")))){            sendHttpResponse(channelHandlerContext,fullHttpRequest,new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,HttpResponseStatus.BAD_REQUEST));        }    }    public void handleWebSocketFrame(ChannelHandlerContext channelHandlerContext,WebSocketFrame webSocketFrame){    }    private static void sendHttpResponse(ChannelHandlerContext channelHandlerContext, FullHttpRequest fullHttpRequest, FullHttpResponse fullHttpResponse){        //返回应答给客户端        if(fullHttpResponse.status().code()!= 200){            ByteBuf byteBuf = Unpooled.copiedBuffer(fullHttpResponse.status().toString(),CharsetUtil.UTF_8);            fullHttpResponse.content().writeBytes(byteBuf);            byteBuf.release();        }        ChannelFuture future = channelHandlerContext.channel().writeAndFlush(fullHttpResponse);        //如果是非keep-alive的话，则关闭连接         List<Map.Entry<CharSequence,CharSequence>> entrys = fullHttpRequest.headers().entries();        for (Map.Entry<CharSequence,CharSequence> item : entrys)  {            if (item.getKey().toString().equals("Connection")){                if (item.getValue().toString().equals("keep-alive")){                    future.addListener(ChannelFutureListener.CLOSE);                }            }        }    }    @Override    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {        cause.printStackTrace();        ctx.close();    }}