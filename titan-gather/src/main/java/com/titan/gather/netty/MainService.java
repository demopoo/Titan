package com.titan.gather.netty;import com.titan.gather.model.ParentMessage;import com.titan.gather.model.message.TitanMessage;import com.titan.gather.netty.handler.HeartBeatResHandler;import com.titan.gather.netty.handler.LoginAuthResHandler;import com.titan.gather.netty.handler.MsgServerHandler;import io.netty.bootstrap.ServerBootstrap;import io.netty.buffer.ByteBuf;import io.netty.buffer.ByteBufAllocator;import io.netty.buffer.ByteBufUtil;import io.netty.buffer.Unpooled;import io.netty.channel.*;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioServerSocketChannel;import io.netty.handler.codec.protobuf.ProtobufDecoder;import io.netty.handler.codec.protobuf.ProtobufEncoder;import io.netty.handler.codec.protobuf.ProtobufVarint32FrameDecoder;import io.netty.handler.codec.protobuf.ProtobufVarint32LengthFieldPrepender;import io.netty.handler.codec.string.StringDecoder;import io.netty.handler.timeout.ReadTimeoutHandler;import java.util.concurrent.ThreadPoolExecutor;/** * @author: yupu * @Date: Created in 下午2:38 2018/9/16 * @Des: * @Modifyed By: */public class MainService {    private int port;    private EventLoopGroup boss;//负责管理链接的线程组    private EventLoopGroup worker;//负责处理消息的线程组    private ServerBootstrap serverBootstrap;//netty启动辅助类    public MainService(int port) {        this.port = port;    }    public void run(){        try {            ByteBuf byteBuf = Unpooled.buffer(1024);            boss = new NioEventLoopGroup();            worker = new NioEventLoopGroup();            serverBootstrap = new ServerBootstrap();            serverBootstrap.group(boss,worker)                    .channel(NioServerSocketChannel.class)                    .option(ChannelOption.SO_BACKLOG,4096)//backlog为 参数并不能影响服务端的连接数，而是影响还未被accept的连接数（官方解释：此参数是请求的套接字上挂起的最大连接数）                    .option(ChannelOption.SO_KEEPALIVE,true)                    .option(ChannelOption.ALLOW_HALF_CLOSURE,false)                    .childHandler(new ChannelInitializer<SocketChannel>() {                        @Override                        protected void initChannel(SocketChannel socketChannel) throws Exception {//                            socketChannel.pipeline().addLast(new LineBasedFrameDecoder(1024));//                            socketChannel.pipeline().addLast(new StringDecoder());                              //固定长度解码器//                            socketChannel.pipeline().addLast(new FixedLengthFrameDecoder(5));//                            socketChannel.pipeline().addLast(new StringDecoder());                              //特殊符号解码器//                            ByteBuf byteBuf = Unpooled.copiedBuffer("`".getBytes());//                            socketChannel.pipeline().addLast(new DelimiterBasedFrameDecoder(1024,byteBuf));//                            socketChannel.pipeline().addLast(new StringDecoder());                            //protobuf 序列化方式                            socketChannel.pipeline().addLast(new ProtobufVarint32FrameDecoder());                            //ParentMessage.parent_message.getDefaultInstance()提供要解码的目标类型,protobuf 自定义                            socketChannel.pipeline().addLast(new ProtobufDecoder(TitanMessage.titan_message.getDefaultInstance()));                            socketChannel.pipeline().addLast(new ProtobufVarint32LengthFieldPrepender());                            socketChannel.pipeline().addLast(new ProtobufEncoder());                            socketChannel.pipeline().addLast(new ReadTimeoutHandler(180));                            socketChannel.pipeline().addLast(new LoginAuthResHandler());//                            socketChannel.pipeline().addLast(new HeartBeatResHandler());//                            socketChannel.pipeline().addLast(new MsgServerHandler());                            //websocket//                            //http-codec 将请求或英达消息编码（或解码）成http消息//                            socketChannel.pipeline().addLast("http-codec",new HttpServerCodec());//                            //aggregator 将http消息的多个组成部分合并成一条http消息//                            socketChannel.pipeline().addLast("aggregator",new HttpObjectAggregator(65535));//                            //http-chunked 向浏览器发送html5文件，主要用于支持服务端和浏览器支持websocket通信//                            socketChannel.pipeline().addLast("http-chunked",new ChunkedWriteHandler());//                            socketChannel.pipeline().addLast("handler",new WebSocketServerHandler());                        }                    });            ChannelFuture channelFuture = serverBootstrap.bind(port).sync();            channelFuture.channel().closeFuture().sync();        }catch (InterruptedException ex){            ex.printStackTrace();        }finally {            boss.shutdownGracefully();            worker.shutdownGracefully();        }    }}