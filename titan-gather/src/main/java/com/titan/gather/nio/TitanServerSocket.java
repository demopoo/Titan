package com.titan.gather.nio;import java.io.IOException;import java.net.InetSocketAddress;import java.nio.ByteBuffer;import java.nio.channels.SelectionKey;import java.nio.channels.Selector;import java.nio.channels.ServerSocketChannel;import java.nio.channels.SocketChannel;import java.nio.charset.Charset;import java.util.*;/** * @author: yupu * @Date: Created in 下午3:17 2018/9/14 * @Des: * @Modifyed By: */public class TitanServerSocket implements Runnable {    private int port;    private ServerSocketChannel serverSocketChannel;    private Selector selector;    private volatile boolean ly = true;    public TitanServerSocket(int port) {        this.port = port;        try {            serverSocketChannel = ServerSocketChannel.open();            serverSocketChannel.configureBlocking(false);            serverSocketChannel.bind(new InetSocketAddress(port),1024);            selector = Selector.open();            serverSocketChannel.register(selector,SelectionKey.OP_ACCEPT);        }catch (IOException ex){            ex.printStackTrace();        }    }    @Override    public void run() {        while (ly){            try {                selector.select(1000);                Set<SelectionKey> selectionKeys = selector.keys();                List<SelectionKey> list = new LinkedList<>();                for (SelectionKey selectionKey : selectionKeys){                    list.add(selectionKey);                }                Iterator<SelectionKey> iterator = list.iterator();                SelectionKey selectionKey = null;                while (iterator.hasNext()){                    selectionKey = iterator.next();                    iterator.remove();                    try {                        selectionHandle(selectionKey);                    }catch (Exception ex){                        if (selectionKey != null){                            selectionKey.cancel();                            if (selectionKey.channel() != null){                                selectionKey.channel().close();                            }                        }                    }                }            }catch (IOException ex){                ex.printStackTrace();            }        }        if (selector != null){            try {                selector.close();            }catch (IOException ex){                ex.printStackTrace();            }        }    }    public void selectionHandle(SelectionKey selectionKey) throws IOException{        //检测该密钥是否有效        if (selectionKey.isValid()){            if (selectionKey.isAcceptable()){                ServerSocketChannel sSocketChannel = (ServerSocketChannel)selectionKey.channel();                SocketChannel socketChannel = sSocketChannel.accept();                socketChannel.configureBlocking(false);                socketChannel.register(selector,SelectionKey.OP_READ);            }            if (selectionKey.isReadable()){                SocketChannel socketChannel = (SocketChannel)selectionKey.channel();                ByteBuffer byteBuffer = ByteBuffer.allocate(1024);                int count = socketChannel.read(byteBuffer);                if (count > 0){                    byteBuffer.flip();                    byte[] bytes = new byte[byteBuffer.remaining()];                    byteBuffer.get(bytes);                    System.out.println(new String(bytes));                    write(socketChannel);                }else if(count <0){                    //一般情况是count = -1 ，表示链路已经关闭了                    selectionKey.cancel();                    socketChannel.close();                }else {                    //未读到数据，常规操作，不用管                }            }        }    }    public void write(SocketChannel socketChannel) throws IOException{        String result = "hello,D. Nice to meet you. I'm so happy ……";        byte[] bytes = result.getBytes(Charset.forName("utf-8"));        ByteBuffer byteBuffer = ByteBuffer.allocate(bytes.length);        byteBuffer.put(bytes);        byteBuffer.flip();        socketChannel.write(byteBuffer);    }}